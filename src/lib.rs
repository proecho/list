//use objects::entrys;

//struct myList<T> {
	//head: Raw<T>,
	//tail: Raw<T>,
	//length: u64,

//#[derive(Debug,PartialEq,Clone)]
//struct a_linked_list<T> {
	//before: Option(Raw<T>),
	//after: Option(Raw<T>),
	//content: Option<entrys<'a>>,
//}

//struct Raw<T>{
	//p: *mut T,
//}

//impl myList<T> {
	//fn compose(&mut self,value:a_linked_list) {
	
		//if self.length == 0 {
			//self.replacetail(&value);
			//self.replacehead(&value);
		
		//}else{
			//self.tail.replace_before(&value);
			//self.replace_tail(&value);
		//}
		
		//mylist.length += 1;
	//} 
		 



















#[cfg(test)]
mod tests {
    #[test]
    fn it_works() {
        assert_eq!(2 + 2, 4);
    }
}
